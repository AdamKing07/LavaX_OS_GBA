add_bp:调用的开销问题，从运算栈传到函数栈是否可以用别的办法省略？经过全面考虑，认为不可以。因为如果不把参数从运算栈传到函数栈，一个带一个参数的函数经过256次递归调用，运算栈就崩溃了。
add_bp传参是如果参数过多还可通过ldm,stm来加速。

ldr(b),str(b)允许带一个12位的偏移量，所以应尽可能的使使用最频繁的char或long型的局部数据靠前（相对与bp的0-0xfff）
ldrsh,strh允许带一个8位的偏移量，所以int型局部变量使用频繁的尽量靠前（0-0xff）

把pop_val修改为movs r10,r10（仅为改变状态位），相应把c_jmpe修改，节省一条指令。不知有否副作用。最好除pop_val都不要改变状态位。
还可以进一步优化：判断后面是否条件转移，如不是，连movs r10,r10也省了。

新版指令集要保证运算栈里面的地址都是纯净的地址（没有表示数据类型和是否local的东西），这样的好处是32位地址完全可用
push_achar,push_aint要通过技术手段统一到push_a。
push_lachar,push_laint要通过技术手段统一到push_la或者push_a。
c_cptr要通过技术手段去除

地址应该是纯地址，增加一个新赋值字节码：lets，lets后面跟一个8位立即数（0:4字节立即数赋值，1:1字节立即数赋值，2:2字节立即数赋值，bit7为0此地址是全局地址，bit7为1此地址是局部地址）

如果支持32位地址，还可把push_string简化为直接push代码段的字符串地址（此时字符串只读），加快运行速度，还节省了一个1K的字符串堆。这样代码段与数据段地址统一到一个空间了。
